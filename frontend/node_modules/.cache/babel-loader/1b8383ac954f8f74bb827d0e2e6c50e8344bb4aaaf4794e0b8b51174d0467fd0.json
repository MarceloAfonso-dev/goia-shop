{"ast":null,"code":"/**\r\n * Gera hash SHA-256 de uma senha usando Web Crypto API\r\n * @param {string} password - Senha em texto plano\r\n * @returns {Promise<string>} - Hash SHA-256 em formato hexadecimal\r\n */export async function hashPassword(password){try{// Verifica se Web Crypto API está disponível\nif(!crypto||!crypto.subtle){throw new Error('Web Crypto API não está disponível neste navegador');}// Converte a string em array de bytes\nconst encoder=new TextEncoder();const data=encoder.encode(password);// Gera o hash SHA-256\nconst hashBuffer=await crypto.subtle.digest('SHA-256',data);// Converte o buffer para string hexadecimal\nconst hashArray=Array.from(new Uint8Array(hashBuffer));const hashHex=hashArray.map(byte=>byte.toString(16).padStart(2,'0')).join('');return hashHex;}catch(error){console.error('Erro na criptografia da senha:',error);throw new Error('Erro na criptografia da senha');}}/**\r\n * Verifica se o Web Crypto está disponível\r\n * @returns {boolean} - True se Web Crypto estiver disponível\r\n */export function isWebCryptoAvailable(){return typeof crypto!=='undefined'&&typeof crypto.subtle!=='undefined'&&typeof crypto.subtle.digest==='function';}/**\r\n * Valida se um CPF é válido usando o algoritmo oficial\r\n * @param {string} cpf - CPF com ou sem formatação\r\n * @returns {boolean} - True se o CPF for válido\r\n */export function validarCPF(cpf){// Remove formatação (pontos, traços, espaços)\nconst cpfLimpo=cpf.replace(/\\D/g,'');// Verifica se tem 11 dígitos\nif(cpfLimpo.length!==11){return false;}// Verifica se todos os dígitos são iguais (CPFs inválidos como 111.111.111-11)\nif(/^(\\d)\\1{10}$/.test(cpfLimpo)){return false;}// Calcula o primeiro dígito verificador\nlet soma=0;for(let i=0;i<9;i++){soma+=parseInt(cpfLimpo.charAt(i))*(10-i);}let resto=soma%11;let digito1=resto<2?0:11-resto;// Verifica o primeiro dígito\nif(parseInt(cpfLimpo.charAt(9))!==digito1){return false;}// Calcula o segundo dígito verificador\nsoma=0;for(let i=0;i<10;i++){soma+=parseInt(cpfLimpo.charAt(i))*(11-i);}resto=soma%11;let digito2=resto<2?0:11-resto;// Verifica o segundo dígito\nif(parseInt(cpfLimpo.charAt(10))!==digito2){return false;}return true;}","map":{"version":3,"names":["hashPassword","password","crypto","subtle","Error","encoder","TextEncoder","data","encode","hashBuffer","digest","hashArray","Array","from","Uint8Array","hashHex","map","byte","toString","padStart","join","error","console","isWebCryptoAvailable","validarCPF","cpf","cpfLimpo","replace","length","test","soma","i","parseInt","charAt","resto","digito1","digito2"],"sources":["D:/PI4/goia-shop/frontend/src/utils/crypto.js"],"sourcesContent":["/**\r\n * Gera hash SHA-256 de uma senha usando Web Crypto API\r\n * @param {string} password - Senha em texto plano\r\n * @returns {Promise<string>} - Hash SHA-256 em formato hexadecimal\r\n */\r\nexport async function hashPassword(password) {\r\n    try {\r\n        // Verifica se Web Crypto API está disponível\r\n        if (!crypto || !crypto.subtle) {\r\n            throw new Error('Web Crypto API não está disponível neste navegador');\r\n        }\r\n\r\n        // Converte a string em array de bytes\r\n        const encoder = new TextEncoder();\r\n        const data = encoder.encode(password);\r\n        \r\n        // Gera o hash SHA-256\r\n        const hashBuffer = await crypto.subtle.digest('SHA-256', data);\r\n        \r\n        // Converte o buffer para string hexadecimal\r\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n        const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');\r\n        \r\n        return hashHex;\r\n    } catch (error) {\r\n        console.error('Erro na criptografia da senha:', error);\r\n        throw new Error('Erro na criptografia da senha');\r\n    }\r\n}\r\n\r\n/**\r\n * Verifica se o Web Crypto está disponível\r\n * @returns {boolean} - True se Web Crypto estiver disponível\r\n */\r\nexport function isWebCryptoAvailable() {\r\n    return typeof crypto !== 'undefined' && \r\n           typeof crypto.subtle !== 'undefined' &&\r\n           typeof crypto.subtle.digest === 'function';\r\n}\r\n\r\n/**\r\n * Valida se um CPF é válido usando o algoritmo oficial\r\n * @param {string} cpf - CPF com ou sem formatação\r\n * @returns {boolean} - True se o CPF for válido\r\n */\r\nexport function validarCPF(cpf) {\r\n    // Remove formatação (pontos, traços, espaços)\r\n    const cpfLimpo = cpf.replace(/\\D/g, '');\r\n    \r\n    // Verifica se tem 11 dígitos\r\n    if (cpfLimpo.length !== 11) {\r\n        return false;\r\n    }\r\n    \r\n    // Verifica se todos os dígitos são iguais (CPFs inválidos como 111.111.111-11)\r\n    if (/^(\\d)\\1{10}$/.test(cpfLimpo)) {\r\n        return false;\r\n    }\r\n    \r\n    // Calcula o primeiro dígito verificador\r\n    let soma = 0;\r\n    for (let i = 0; i < 9; i++) {\r\n        soma += parseInt(cpfLimpo.charAt(i)) * (10 - i);\r\n    }\r\n    let resto = soma % 11;\r\n    let digito1 = resto < 2 ? 0 : 11 - resto;\r\n    \r\n    // Verifica o primeiro dígito\r\n    if (parseInt(cpfLimpo.charAt(9)) !== digito1) {\r\n        return false;\r\n    }\r\n    \r\n    // Calcula o segundo dígito verificador\r\n    soma = 0;\r\n    for (let i = 0; i < 10; i++) {\r\n        soma += parseInt(cpfLimpo.charAt(i)) * (11 - i);\r\n    }\r\n    resto = soma % 11;\r\n    let digito2 = resto < 2 ? 0 : 11 - resto;\r\n    \r\n    // Verifica o segundo dígito\r\n    if (parseInt(cpfLimpo.charAt(10)) !== digito2) {\r\n        return false;\r\n    }\r\n    \r\n    return true;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}